"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnimplementedExpression = exports.Expression = void 0;
const util_1 = require("../util/util");
const builder_1 = require("./builder");
class Expression {
    constructor(json) {
        if (json.operand != null) {
            const op = (0, builder_1.build)(json.operand);
            if ((0, util_1.typeIsArray)(json.operand)) {
                this.args = op;
            }
            else {
                this.arg = op;
            }
        }
        if (json.localId != null) {
            this.localId = json.localId;
        }
    }
    execute(ctx) {
        if (this.localId != null) {
            // Store the localId and result on the root context of this library
            const execValue = this.exec(ctx);
            ctx.rootContext().setLocalIdWithResult(this.localId, execValue);
            return execValue;
        }
        else {
            return this.exec(ctx);
        }
    }
    exec(_ctx) {
        return this;
    }
    execArgs(ctx) {
        if (this.args != null) {
            return this.args.map(arg => arg.execute(ctx));
        }
        else if (this.arg != null) {
            return this.arg.execute(ctx);
        }
        else {
            return null;
        }
    }
}
exports.Expression = Expression;
class UnimplementedExpression extends Expression {
    constructor(json) {
        super(json);
        this.json = json;
    }
    exec(_ctx) {
        throw new Error(`Unimplemented Expression: ${this.json.type}`);
    }
}
exports.UnimplementedExpression = UnimplementedExpression;
//# sourceMappingURL=expression.js.map