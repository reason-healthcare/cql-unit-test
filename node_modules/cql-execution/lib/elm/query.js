"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryLetRef = exports.AliasRef = exports.Query = exports.SortClause = exports.ReturnClause = exports.ByColumn = exports.ByExpression = exports.ByDirection = exports.Sort = exports.Without = exports.With = exports.LetClause = exports.AliasedQuerySource = void 0;
const expression_1 = require("./expression");
const context_1 = require("../runtime/context");
const util_1 = require("../util/util");
const comparison_1 = require("../util/comparison");
const builder_1 = require("./builder");
class AliasedQuerySource {
    constructor(json) {
        this.alias = json.alias;
        this.expression = (0, builder_1.build)(json.expression);
    }
}
exports.AliasedQuerySource = AliasedQuerySource;
class LetClause {
    constructor(json) {
        this.identifier = json.identifier;
        this.expression = (0, builder_1.build)(json.expression);
    }
}
exports.LetClause = LetClause;
class With extends expression_1.Expression {
    constructor(json) {
        super(json);
        this.alias = json.alias;
        this.expression = (0, builder_1.build)(json.expression);
        this.suchThat = (0, builder_1.build)(json.suchThat);
    }
    exec(ctx) {
        let records = this.expression.execute(ctx);
        if (!(0, util_1.typeIsArray)(records)) {
            records = [records];
        }
        const returns = records.map((rec) => {
            const childCtx = ctx.childContext();
            childCtx.set(this.alias, rec);
            return this.suchThat.execute(childCtx);
        });
        return returns.some((x) => x);
    }
}
exports.With = With;
class Without extends With {
    constructor(json) {
        super(json);
    }
    exec(ctx) {
        return !super.exec(ctx);
    }
}
exports.Without = Without;
// ELM-only, not a product of CQL
class Sort extends expression_1.UnimplementedExpression {
}
exports.Sort = Sort;
class ByDirection extends expression_1.Expression {
    constructor(json) {
        super(json);
        this.direction = json.direction;
        this.low_order = this.direction === 'asc' || this.direction === 'ascending' ? -1 : 1;
        this.high_order = this.low_order * -1;
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    exec(ctx, a, b) {
        if (a === b) {
            return 0;
        }
        else if (a.isQuantity && b.isQuantity) {
            if (a.before(b)) {
                return this.low_order;
            }
            else {
                return this.high_order;
            }
        }
        else if (a < b) {
            return this.low_order;
        }
        else {
            return this.high_order;
        }
    }
}
exports.ByDirection = ByDirection;
class ByExpression extends expression_1.Expression {
    constructor(json) {
        super(json);
        this.expression = (0, builder_1.build)(json.expression);
        this.direction = json.direction;
        this.low_order = this.direction === 'asc' || this.direction === 'ascending' ? -1 : 1;
        this.high_order = this.low_order * -1;
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    exec(ctx, a, b) {
        let sctx = ctx.childContext(a);
        const a_val = this.expression.execute(sctx);
        sctx = ctx.childContext(b);
        const b_val = this.expression.execute(sctx);
        if (a_val === b_val || (a_val == null && b_val == null)) {
            return 0;
        }
        else if (a_val == null || b_val == null) {
            return a_val == null ? this.low_order : this.high_order;
        }
        else if (a_val.isQuantity && b_val.isQuantity) {
            return a_val.before(b_val) ? this.low_order : this.high_order;
        }
        else {
            return a_val < b_val ? this.low_order : this.high_order;
        }
    }
}
exports.ByExpression = ByExpression;
class ByColumn extends ByExpression {
    constructor(json) {
        super(json);
        this.expression = (0, builder_1.build)({
            name: json.path,
            type: 'IdentifierRef'
        });
    }
}
exports.ByColumn = ByColumn;
class ReturnClause {
    constructor(json) {
        this.expression = (0, builder_1.build)(json.expression);
        this.distinct = json.distinct != null ? json.distinct : true;
    }
}
exports.ReturnClause = ReturnClause;
class SortClause {
    constructor(json) {
        this.by = (0, builder_1.build)(json != null ? json.by : undefined);
    }
    sort(ctx, values) {
        if (this.by) {
            return values.sort((a, b) => {
                let order = 0;
                for (const item of this.by) {
                    // Do not use execute here because the value of the sort order is not important.
                    order = item.exec(ctx, a, b);
                    if (order !== 0) {
                        break;
                    }
                }
                return order;
            });
        }
    }
}
exports.SortClause = SortClause;
const toDistinctList = function (xList) {
    const yList = [];
    xList.forEach(x => {
        if (!yList.some(y => (0, comparison_1.equals)(x, y))) {
            yList.push(x);
        }
    });
    return yList;
};
class AggregateClause extends expression_1.Expression {
    constructor(json) {
        super(json);
        this.identifier = json.identifier;
        this.expression = (0, builder_1.build)(json.expression);
        this.starting = json.starting ? (0, builder_1.build)(json.starting) : null;
        this.distinct = json.distinct != null ? json.distinct : true;
    }
    aggregate(returnedValues, ctx) {
        let aggregateValue = this.starting != null ? this.starting.exec(ctx) : null;
        returnedValues.forEach((contextValues) => {
            const childContext = ctx.childContext(contextValues);
            childContext.set(this.identifier, aggregateValue);
            aggregateValue = this.expression.exec(childContext);
        });
        return aggregateValue;
    }
}
class Query extends expression_1.Expression {
    constructor(json) {
        super(json);
        this.sources = new MultiSource(json.source.map((s) => new AliasedQuerySource(s)));
        this.letClauses = json.let != null ? json.let.map((d) => new LetClause(d)) : [];
        this.relationship = json.relationship != null ? (0, builder_1.build)(json.relationship) : [];
        this.where = (0, builder_1.build)(json.where);
        this.returnClause = json.return != null ? new ReturnClause(json.return) : null;
        this.aggregateClause = json.aggregate != null ? new AggregateClause(json.aggregate) : null;
        this.aliases = this.sources.aliases();
        this.sortClause = json.sort != null ? new SortClause(json.sort) : null;
    }
    isDistinct() {
        if (this.aggregateClause != null && this.aggregateClause.distinct != null) {
            return this.aggregateClause.distinct;
        }
        else if (this.returnClause != null && this.returnClause.distinct != null) {
            return this.returnClause.distinct;
        }
        return true;
    }
    exec(ctx) {
        let returnedValues = [];
        this.sources.forEach(ctx, (rctx) => {
            for (const def of this.letClauses) {
                rctx.set(def.identifier, def.expression.execute(rctx));
            }
            const relations = this.relationship.map(rel => {
                const child_ctx = rctx.childContext();
                return rel.execute(child_ctx);
            });
            const passed = (0, util_1.allTrue)(relations) && (this.where ? this.where.execute(rctx) : true);
            if (passed) {
                if (this.returnClause != null) {
                    const val = this.returnClause.expression.execute(rctx);
                    returnedValues.push(val);
                }
                else {
                    if (this.aliases.length === 1 && this.aggregateClause == null) {
                        returnedValues.push(rctx.get(this.aliases[0]));
                    }
                    else {
                        returnedValues.push(rctx.context_values);
                    }
                }
            }
        });
        if (this.isDistinct()) {
            returnedValues = toDistinctList(returnedValues);
        }
        if (this.aggregateClause != null) {
            returnedValues = this.aggregateClause.aggregate(returnedValues, ctx);
        }
        if (this.sortClause != null) {
            this.sortClause.sort(ctx, returnedValues);
        }
        if (this.sources.returnsList() || this.aggregateClause != null) {
            return returnedValues;
        }
        else {
            return returnedValues[0];
        }
    }
}
exports.Query = Query;
class AliasRef extends expression_1.Expression {
    constructor(json) {
        super(json);
        this.name = json.name;
    }
    exec(ctx) {
        return ctx != null ? ctx.get(this.name) : undefined;
    }
}
exports.AliasRef = AliasRef;
class QueryLetRef extends AliasRef {
    constructor(json) {
        super(json);
    }
}
exports.QueryLetRef = QueryLetRef;
// The following is not defined by ELM but is helpful for execution
class MultiSource {
    constructor(sources) {
        this.sources = sources;
        this.alias = this.sources[0].alias;
        this.expression = this.sources[0].expression;
        this.isList = true;
        if (this.sources.length > 1) {
            this.rest = new MultiSource(this.sources.slice(1));
        }
    }
    aliases() {
        let a = [this.alias];
        if (this.rest) {
            a = a.concat(this.rest.aliases());
        }
        return a;
    }
    returnsList() {
        return this.isList || (this.rest && this.rest.returnsList());
    }
    forEach(ctx, func) {
        let records = this.expression.execute(ctx);
        this.isList = (0, util_1.typeIsArray)(records);
        records = this.isList ? records : [records];
        return records.map((rec) => {
            const rctx = new context_1.Context(ctx);
            rctx.set(this.alias, rec);
            if (this.rest) {
                return this.rest.forEach(rctx, func);
            }
            else {
                return func(rctx);
            }
        });
    }
}
//# sourceMappingURL=query.js.map