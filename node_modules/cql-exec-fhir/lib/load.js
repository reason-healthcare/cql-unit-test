"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var fs = require('fs');

var xml2js = require('xml2js');

var processors = require('xml2js/lib/processors');

function load(filePathOrXML) {
  var xml, name;

  if (/^\s*<[\s\S]+>\s*$/.test(filePathOrXML)) {
    xml = filePathOrXML;
    name = 'XML';
  } else {
    xml = fs.readFileSync(filePathOrXML, 'utf8');
    name = filePathOrXML;
  }

  var modelInfo;
  var opts = {
    async: false,
    tagNameProcessors: [processors.stripPrefix],
    attrNameProcessors: [processors.stripPrefix]
  };
  xml2js.parseString(xml, opts, function (err, result) {
    if (err != null) {
      console.error("Failed to load model info from ".concat(name, ":"), err);
      return;
    } else if (result.modelInfo == null) {
      console.error("Model info is not valid for ".concat(name));
      return;
    }

    modelInfo = new ModelInfo(result.modelInfo);
  });
  return modelInfo;
}

var ModelInfo = /*#__PURE__*/function () {
  function ModelInfo(xml) {
    _classCallCheck(this, ModelInfo);

    this._name = xml.$.name;
    this._version = xml.$.version;
    this._url = xml.$.url;
    this._schemaLocation = xml.$.schemaLocation;
    this._targetQualifier = xml.$.targetQualifier;
    this._patientClassName = xml.$.patientClassName;
    this._patientClassIdentifier = xml.$.patientClassIdentifier;
    this._patientBirthDatePropertyName = xml.$.patientBirthDatePropertyName;
    this._caseSensitive = xml.$.caseSensitive;
    this._strictRetrieveTyping = xml.$.strictRetrieveTyping;
    this._classesByLabel = new Map();
    this._classesByIdentifier = new Map();
    this._classesByName = new Map();

    var _iterator = _createForOfIteratorHelper(xml.typeInfo),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var t = _step.value;

        if (t.$ != null && (stripNS(t.$.type) === 'ClassInfo' || stripNS(t.$.type) === 'ProfileInfo')) {
          var classInfo = new ClassInfo(t, this);

          if (classInfo.label != null) {
            this._classesByLabel.set(classInfo.label, classInfo);
          }

          if (classInfo.identifier != null) {
            this._classesByIdentifier.set(classInfo.identifier, classInfo);
          }

          if (classInfo.name != null) {
            this._classesByName.set(classInfo.name, classInfo);
          }
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  _createClass(ModelInfo, [{
    key: "name",
    get: function get() {
      return this._name;
    }
  }, {
    key: "version",
    get: function get() {
      return this._version;
    }
  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
  }, {
    key: "schemaLocation",
    get: function get() {
      return this._schemaLocation;
    }
  }, {
    key: "targetQualifier",
    get: function get() {
      return this._targetQualifier;
    }
  }, {
    key: "patientClassName",
    get: function get() {
      return this._patientClassName;
    }
  }, {
    key: "patientClassIdentifier",
    get: function get() {
      return this._patientClassIdentifier;
    }
  }, {
    key: "patientBirthDatePropertyName",
    get: function get() {
      return this._patientBirthDatePropertyName;
    }
  }, {
    key: "caseSensitive",
    get: function get() {
      return this._caseSensitive;
    }
  }, {
    key: "strictRetrieveTyping",
    get: function get() {
      return this._strictRetrieveTyping;
    }
  }, {
    key: "findClass",
    value: function findClass(klass) {
      // First check label, then identifier, then name
      if (this._classesByLabel.has(klass)) {
        return this._classesByLabel.get(klass);
      } else if (this._classesByIdentifier.has(klass)) {
        return this._classesByIdentifier.get(klass);
      } // If label or identifier aren't used, it might come in as something like {http://hl7.org/fhir}MedicationStatement.
      // If the URL matches the model URL, then swap out the namespace with the model name (and a dot).  Otherwise this
      // will keep the name as-is.


      var klassName = klass.replace("{".concat(this.url, "}"), "".concat(this.name, "."));

      if (this._classesByName.has(klassName)) {
        return this._classesByName.get(klassName);
      } // Last ditch effort by name: if it starts with the model prefix (e.g., FHIR.Patient) then remove it; OR if it
      // doesn't start with the model prefix (e.g. Patient), add it.


      var modKlassName = klassName.startsWith("".concat(this.name, ".")) ? klassName.slice(this.name.length + 1) : "".concat(this.name, ".").concat(klassName);
      return this._classesByName.get(modKlassName);
    }
  }]);

  return ModelInfo;
}();

var ClassInfo = /*#__PURE__*/function () {
  function ClassInfo(xml, modelInfo) {
    _classCallCheck(this, ClassInfo);

    this._namespace = xml.$.namespace || modelInfo.url;
    this._name = xml.$.name;
    this._identifier = xml.$.identifier;
    this._label = xml.$.label;
    this._isRetrievable = xml.$.retrievable == 'true';
    this._primaryCodePath = xml.$.primaryCodePath;
    this._baseTypeSpecifier = getTypeSpecifierFromXML(xml, 'base');
    this._modelInfo = modelInfo;
    this._elementsByName = new Map();

    if (xml.element != null) {
      var _iterator2 = _createForOfIteratorHelper(xml.element),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var e = _step2.value;
          var element = new ClassElement(e, modelInfo);

          this._elementsByName.set(element.name, element);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    this._parentClasses = null; //lazy loaded
  }

  _createClass(ClassInfo, [{
    key: "namespace",
    get: function get() {
      return this._namespace;
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
  }, {
    key: "identifier",
    get: function get() {
      return this._identifier;
    }
  }, {
    key: "label",
    get: function get() {
      return this._label;
    }
  }, {
    key: "isRetrievable",
    get: function get() {
      return this._isRetrievable;
    }
  }, {
    key: "primaryCodePath",
    get: function get() {
      return this._primaryCodePath;
    }
  }, {
    key: "baseTypeSpecifier",
    get: function get() {
      return this._baseTypeSpecifier;
    }
  }, {
    key: "modelInfo",
    get: function get() {
      return this._modelInfo;
    }
  }, {
    key: "elements",
    get: function get() {
      return Array.from(this._elementsByName.values());
    } // @return NamedTypeSpecifier

  }, {
    key: "parentClasses",
    value: function parentClasses() {
      if (!this._parentClasses) {
        this._parentClasses = [];

        if (this.baseTypeSpecifier) {
          var _this$_parentClasses;

          var parentClass = this._modelInfo.findClass(this.baseTypeSpecifier.name);

          if (parentClass) (_this$_parentClasses = this._parentClasses).push.apply(_this$_parentClasses, [parentClass].concat(_toConsumableArray(parentClass.parentClasses())));
        }
      }

      return this._parentClasses;
    }
    /**
     * Finds an element by name, optionally allowing for explicit choice names. If explicit choice names
     * are allowed, then if 'medicationCodeableConcept' is passed in, but the real element name is
     * 'medication' and it is a choice where 'CodeableConcept' is a valid option type, then it will return
     * that.  If explicit choice names are not allowed, it will return `undefined`.  Technically, explicit
     * choicenames won't come up often -- likely only when a ModelInfo uses one as its primaryCodePath or
     * primaryDatePath (and even then, some might consider that a bug in the ModelInfo).
     * @param {string} el - the name of the element to find
     * @param {boolean} allowExplicitChoice - indicates if explicit choice names are allowed
     * @return {ClassElement}
     */

  }, {
    key: "findElement",
    value: function findElement(el) {
      var allowExplicitChoice = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var element = this._elementsByName.get(el); // TODO: Should we add support for when the base type is a System type?


      if (element == null && this.baseTypeSpecifier != null && this.baseTypeSpecifier.namespace !== 'System') {
        element = this._modelInfo.findClass(this.baseTypeSpecifier.fqn).findElement(el);
      }

      if (element == null && allowExplicitChoice) {
        // Now go through the name checking possible combinations of name and type for explicit choices
        // E.g., medicationCodeableConcept -> medication / CodeableConcept -> medicationCodeable / Concept
        for (var i = 0; i < el.length; i++) {
          if (/^[A-Z]$/.test(el[i])) {
            var name = el.slice(0, i);
            var potential = this.findElement(name, false);

            if (potential != null && potential.typeSpecifier && potential.typeSpecifier.isChoice) {
              var _ret = function () {
                var explicitType = el.slice(i);
                var typeMatchesChoice = potential.typeSpecifier.choices.find(function (c) {
                  return c.name === explicitType || c.name === "".concat(explicitType[0].toLowerCase()).concat(explicitType.slice(1));
                });

                if (typeMatchesChoice) {
                  element = potential;
                  return "break";
                }
              }();

              if (_ret === "break") break;
            }
          }
        }
      }

      return element;
    }
  }]);

  return ClassInfo;
}();

var ClassElement = /*#__PURE__*/function () {
  function ClassElement(xml, modelInfo) {
    _classCallCheck(this, ClassElement);

    this._name = xml.$.name;
    this._typeSpecifier = getTypeSpecifierFromXML(xml, '', 'element');
    this._isProhibited = xml.$.prohibited == 'true';
    this._isOneBased = xml.$.oneBased === 'true';
    this._modelInfo = modelInfo;
  }

  _createClass(ClassElement, [{
    key: "name",
    get: function get() {
      return this._name;
    }
  }, {
    key: "typeSpecifier",
    get: function get() {
      return this._typeSpecifier;
    }
  }, {
    key: "isProhibited",
    get: function get() {
      return this._isProhibited;
    }
  }]);

  return ClassElement;
}();

var NAMED_TYPE_NAME = 'NamedTypeSpecifier';
var NAMED_TYPE_RE = /^(([^.<>]+)\.)?([^<>]+)$/;

var NamedTypeSpecifier = /*#__PURE__*/function () {
  function NamedTypeSpecifier(name, namespace) {
    _classCallCheck(this, NamedTypeSpecifier);

    this._name = name;
    this._namespace = namespace;
  }

  _createClass(NamedTypeSpecifier, [{
    key: "isNamed",
    get: function get() {
      return true;
    }
  }, {
    key: "name",
    get: function get() {
      return this._name;
    }
  }, {
    key: "namespace",
    get: function get() {
      return this._namespace;
    }
  }, {
    key: "fqn",
    get: function get() {
      return this.namespace == null ? this.name : "".concat(this.namespace, ".").concat(this.name);
    }
  }]);

  return NamedTypeSpecifier;
}();

var LIST_TYPE_NAME = 'ListTypeSpecifier';
var LIST_TYPE_RE = /^[Ll]ist\s*<\s*(.*[^\s])\s*>$/;

var ListTypeSpecifier = /*#__PURE__*/function () {
  function ListTypeSpecifier(elementType) {
    _classCallCheck(this, ListTypeSpecifier);

    this._elementType = elementType;
  }

  _createClass(ListTypeSpecifier, [{
    key: "isList",
    get: function get() {
      return true;
    }
  }, {
    key: "elementType",
    get: function get() {
      return this._elementType;
    }
  }]);

  return ListTypeSpecifier;
}();

var INTERVAL_TYPE_NAME = 'IntervalTypeSpecifier';
var INTERVAL_TYPE_RE = /^[Ii]nterval\s*<\s*(.*[^\s])\s*>$/;

var IntervalTypeSpecifier = /*#__PURE__*/function () {
  function IntervalTypeSpecifier(pointType) {
    _classCallCheck(this, IntervalTypeSpecifier);

    this._pointType = pointType;
  }

  _createClass(IntervalTypeSpecifier, [{
    key: "isInterval",
    get: function get() {
      return true;
    }
  }, {
    key: "pointType",
    get: function get() {
      return this._pointType;
    }
  }]);

  return IntervalTypeSpecifier;
}();

var CHOICE_TYPE_NAME = 'ChoiceTypeSpecifier';
var CHOICE_TYPE_RE = /^[Cc]hoice\s*<\s*(.*[^\s])\s*>$/;

var ChoiceTypeSpecifier = /*#__PURE__*/function () {
  function ChoiceTypeSpecifier(choices) {
    _classCallCheck(this, ChoiceTypeSpecifier);

    this._choices = choices;
  }

  _createClass(ChoiceTypeSpecifier, [{
    key: "isChoice",
    get: function get() {
      return true;
    }
  }, {
    key: "choices",
    get: function get() {
      return this._choices;
    }
  }]);

  return ChoiceTypeSpecifier;
}();

function getTypeSpecifierFromXML(xml) {
  var type, typeSpecifier; // loop through prefixes looking for type property (e.g., type, elementType, pointType, etc.)

  for (var _len = arguments.length, prefixes = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    prefixes[_key - 1] = arguments[_key];
  }

  if (xml.$) {
    for (var i = 0; type == null && i < prefixes.length; i++) {
      type = prefixes[i] === '' ? stripNS(xml.$.type) : stripNS(xml.$["".concat(prefixes[i], "Type")]);
    }
  } // loop through prefixes looking for typeSpecifier property (e.g., typeSpecifier, elementTypeSpecifier, etc.)


  for (var _i = 0; typeSpecifier == null && _i < prefixes.length; _i++) {
    typeSpecifier = prefixes[_i] === '' ? xml.typeSpecifier : xml["".concat(prefixes[_i], "TypeSpecifier")];
  }

  if (typeSpecifier && typeSpecifier.length > 0) {
    typeSpecifier = typeSpecifier[0];
  }

  return getTypeSpecifier(type, typeSpecifier);
}

function getTypeSpecifier(stringType, xmlTypeSpecifier) {
  // NamedTypeSpecifier
  if (stringType && NAMED_TYPE_RE.test(stringType)) {
    var m = NAMED_TYPE_RE.exec(stringType);
    return new NamedTypeSpecifier(m[3], m[2]);
  } else if (xmlTypeSpecifier && stripNS(xmlTypeSpecifier.$.type) === NAMED_TYPE_NAME) {
    var name = xmlTypeSpecifier.$.name;
    var namespace = xmlTypeSpecifier.$.modelName || xmlTypeSpecifier.$.namespace;
    return new NamedTypeSpecifier(name, namespace);
  } // ListTypeSpecifier
  else if (stringType && LIST_TYPE_RE.test(stringType)) {
    var _m = LIST_TYPE_RE.exec(stringType);

    return new ListTypeSpecifier(getTypeSpecifier(_m[1]));
  } else if (xmlTypeSpecifier && stripNS(xmlTypeSpecifier.$.type) === LIST_TYPE_NAME) {
    return new ListTypeSpecifier(getTypeSpecifierFromXML(xmlTypeSpecifier, 'element'));
  } // IntervalTypeSpecifier
  else if (stringType && INTERVAL_TYPE_RE.test(stringType)) {
    var _m2 = INTERVAL_TYPE_RE.exec(stringType);

    return new IntervalTypeSpecifier(getTypeSpecifier(_m2[1]));
  } else if (xmlTypeSpecifier && stripNS(xmlTypeSpecifier.$.type) === INTERVAL_TYPE_NAME) {
    return new IntervalTypeSpecifier(getTypeSpecifierFromXML(xmlTypeSpecifier, 'point'));
  } // ChoiceTypeSpecifier
  else if (stringType && CHOICE_TYPE_RE.test(stringType)) {
    // NOTE: The string type attribute variant does not support choices nested in choices
    var _m3 = INTERVAL_TYPE_RE.exec(stringType);

    var choiceStrings = _m3[1].split(',').map(function (c) {
      return c.trim();
    });

    var choices = choiceStrings.map(function (c) {
      return getTypeSpecifier(c);
    });
    return new ChoiceTypeSpecifier(choices);
  } else if (xmlTypeSpecifier && stripNS(xmlTypeSpecifier.$.type) === CHOICE_TYPE_NAME) {
    var _choices = xmlTypeSpecifier.choice.map(function (c) {
      return getTypeSpecifier(null, c);
    });

    return new ChoiceTypeSpecifier(_choices);
  }

  return;
}

function stripNS(str) {
  if (str == null) {
    return str;
  }

  return str.replace(/.*:/, '');
}

module.exports = load;